# UNIT TESTING JAVA (JUNIT 5)

## Introducci√≥n

Las pruebas unitarias son una t√©cnica de programaci√≥n que consiste en realizar pruebas automatizadas para verificar el correcto funcionamiento de una unidad de c√≥digo. Una unidad de c√≥digo puede ser un m√©todo, una clase, un paquete, un componente, etc. Las pruebas unitarias se realizan de forma aislada, es decir, se prueban las unidades de c√≥digo de forma independiente, sin depender de otras unidades de c√≥digo o componentes.

### Testing tradicional

El testing tradicional se realiza de forma manual:

- Directamente desde el c√≥digo fuente.
- Via app m√≥vil o web.
- Con herramientas como POSTSMAN para API Rest.

En general podemos decir que:

- Requieren mucho tiempo y es lento. A medida que la aplicaci√≥n crece, el tiempo de pruebas tambi√©n crece.
- No nos reporta si falla, d√≥nde y por qu√©
- Habr√° que repetir las pruebas cada vez que se haga un cambio en el c√≥digo.
- No se pueden automatizar.
- Habr√° casos de uso que no se prueben, o que se prueben unas veces y otras no.


### Testing automatizado

Las caracter√≠sticas del testing automatizado son:

- Autom√°tico y r√°pido.
- Nos permite disponer de un conjunto de pruebas definido.
- Nos ofrece un reporte de las pruebas.
  - Si falla, d√≥nde y pro qu√©.
- Nos garantiza su funcionamiento tras cambios.


## Tipos de Test

- Pruebas unitarias
  - Menor coste
  - Mayor n√∫mero de test.
  - M√°ximo aislamiento.
- Integraci√≥n
- Aceptaci√≥n
  - M√°s coste.
    - Menor n√∫mero de test.
    - M√°xima integraci√≥n.


<img src="./img/doc_utj_01.png" width="80%">


### Requisitos para hacer Testing

- Comprender el funcionamiento de nuestra aplicaci√≥n
- Conocer cu√°les son nuestras clases.
- Reglas de negocio o casos de uso.

### Pruebas unitarias

- M√©todos que permite verificar una parte del c√≥digo.
- Comprueban que, para unos datos de entrada, devuelve el resultado esperado.
- Permiten la veridicaci√≥n de las reglas de negocio de forma aislada.


**¬øQu√© es una prueba?**

Las pruebas unitarias casi siempre se centran en pruebas de "Caja Negra", donde para unos datos de entrada se esperan unos datos de salida.



### JUnit

Realizar las pruebas de forma manual puede ser tedioso y propenso a errores. Por ello, existen frameworks que facilitan la creaci√≥n y ejecuci√≥n de pruebas unitarias. Uno de los frameworks m√°s populares para realizar pruebas unitarias en Java es JUnit.

Aparte de JUnit, existen otros frameworks de pruebas unitarias en Java, como TestNG, Mockito, PowerMock, etc, pero por su popularidad y simplicidad, JUnit es el m√°s utilizado.

JUnit es un framework de pruebas unitarias para el lenguaje de programaci√≥n Java

Caracter√≠sticas de JUnit:

- Permite escribir y ejecutar pruebas unitarias de forma sencilla.
- Proporciona anotaciones para definir m√©todos de prueba.
- Proporciona m√©todos de aserci√≥n para verificar los resultados de las pruebas.
- Proporciona herramientas para la ejecuci√≥n de pruebas y la generaci√≥n de informes.
- Proporciona herramientas para la organizaci√≥n de pruebas en suites de pruebas.
- Las pruebas son repetibles y se pueden ejecutar de forma autom√°tica.


### Instalaci√≥n de JUnit

Para utilizar JUnit en un proyecto Java, es necesario a√±adir la librer√≠a de JUnit al proyecto, y esto se puede realizar de varias formas:

- Manualmente a√±adiendo el archivo JAR de JUnit al proyecto.
- Utilizando una herramienta de gesti√≥n de dependencias como Maven o Gradle.


#### JUNIT 4 vs JUNIT 5

JUnit 4 es la versi√≥n anterior de JUnit, y JUnit 5 es la versi√≥n m√°s reciente de JUnit. JUnit 5 es una versi√≥n completamente nueva de JUnit que se lanz√≥ en septiembre de 2017. JUnit 5 es una reescritura completa de JUnit 4 y ofrece muchas nuevas caracter√≠sticas y mejoras sobre JUnit 4.

A continuaci√≥n, se muestra una tabla comparativa de las caracter√≠sticas de JUnit 4 y JUnit 5:

| Caracter√≠stica | JUnit 4 | JUnit 5 |
| --- | --- | --- |
| Arquitectura | Basada en JUnit 3 | Basada en JUnit Platform |
| Anotaciones | @Test, @Before, @After, @BeforeClass, @AfterClass | @Test, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll |
| Extensiones | No | S√≠ |
| Anotaciones de extensi√≥n | No | @ExtendWith |
| Anotaciones de repetici√≥n | No | @RepeatedTest |
| Anotaciones de par√°metros | No | @ParameterizedTest |
| Anotaciones de excepci√≥n | @Test(expected = Exception.class) | @Test(expected = Exception.class) |
| Anotaciones de tiempo de espera | @Test(timeout = 1000) | @Test(timeout = 1000) |
| Anotaciones de deshabilitaci√≥n | @Ignore | @Disabled |
| Anotaciones de etiquetas | No | @Tag |
| Anotaciones de anidamiento | No | @Nested |
| Anotaciones de prueba condicional | No | @EnabledOnOs, @EnabledOnJre, @EnabledIf, @EnabledIfSystemProperty, @EnabledIfEnvironmentVariable |
| Anotaciones de inyecci√≥n de dependencias | No | @RegisterExtension |
| Anotaciones de configuraci√≥n de extensi√≥n | No | @RegisterExtension |
| Anotaciones de manejo de excepciones | No | @ExceptionHandler |
| Anotaciones de tiempo de vida de la extensi√≥n | No | @ExtendWith |
| Anotaciones de prueba de interfaz funcional | No | @Testable |


#### JUnit 5

Anotaciones m√°s importantes de JUnit 5:

- @Test: Indica que el m√©todo es un m√©todo de prueba.
- @BeforeEach: Indica que el m√©todo se ejecuta antes de cada m√©todo de prueba.
- @AfterEach: Indica que el m√©todo se ejecuta despu√©s de cada m√©todo de prueba.
- @BeforeAll: Indica que el m√©todo se ejecuta antes de todos los m√©todos de prueba.
- @AfterAll: Indica que el m√©todo se ejecuta despu√©s de todos los m√©todos de prueba.

Otras anotaciones de JUnit 5:

- @DisplayName: Permite definir un nombre personalizado para el m√©todo de prueba.
- @Disabled: Indica que el m√©todo de prueba est√° deshabilitado.
- @Ignore: Indica que el m√©todo de prueba est√° deshabilitado.
- @Order: Indica el orden de ejecuci√≥n de los m√©todos de prueba.
- @EnabledOnOs: Indica que el m√©todo de prueba se ejecuta en un sistema operativo espec√≠fico.
- @EnabledOnJre: Indica que el m√©todo de prueba se ejecuta en una versi√≥n espec√≠fica de la JVM.
- @RepeatedTest: Indica que el m√©todo de prueba se repite un n√∫mero espec√≠fico de veces.
- @ParameterizedTest: Indica que el m√©todo de prueba se ejecuta con diferentes par√°metros.
- @Tag: Permite etiquetar los m√©todos de prueba. Se pueden agrupar los m√©todos de prueba por etiquetas y ejecutar solo los m√©todos de prueba que tengan una etiqueta espec√≠fica.
- @Nested: Permite anidar clases de prueba. Se pueden anidar clases de prueba para organizar las pruebas de forma jer√°rquica. Cada clase de prueba anidada se ejecuta de forma independiente.


### Primeras pruebas unitarias con JUnit

- Cada prueba se realiza en un m√©todo anotado con @Test.
- Si falla una condici√≥n (assertion) en un test, √©ste falla.
- Las instancias a nivel de clase son diferentes para cada test.
- **El orden de las pruebas no importa**


#### Asserts

Los asserts son m√©todos que permiten verificar si una condici√≥n es verdadera o falsa. Si la condici√≥n es verdadera, la prueba contin√∫a. Si la condici√≥n es falsa, la prueba falla.

Algunos m√©todos de aserci√≥n m√°s comunes en JUnit son:

- assertTrue/assertFalse: Verifica si una condici√≥n es verdadera/falsa.
- assertEquals: Verifica si dos valores son iguales.
- assertNotEquals: Verifica si dos valores no son iguales.
- assertNull/assertNotNull: Verifica si un valor es nulo/no nulo.
- assertSame/assertNotSame: Verifica si dos referencias apuntan al mismo objeto/no al mismo objeto.
- assertThat: Verifica si un valor cumple una condici√≥n.
- assertThrows: Verifica si una excepci√≥n es lanzada.
- assertTimeout: Verifica si una operaci√≥n se ejecuta en un tiempo determinado.
- assertAll: Verifica varias condiciones a la vez.

Tambi√©n podemos hacer que una prueba falle de forma controlada con el m√©todo `fail()`.

#### Ejemplo

En el siguiente ejemplo se quiere comprobar que el m√©todo `sendProduct`acutaliza el stock de la tienda.

  
```java
@Test
void itShoutldRemoveFromStore() {
  Product product = new Product("Coca-Cola", 10);
  Store store = new Store("Store", List.of(product, product, product));

  storeService.sendProduct(product);
  assertNotNull(store.getProducts());
  assertEquals(2, store.getProducts().size());
}
```

Los m√©todos `assert`pueden reportar mensajes de fallos personalizados:

- Se pasan como √∫ltimo par√°metro del m√©todo como un `String` o como una expresi√≥n lambda.

Ejemplos:

- assertEquals(2, store.getProducts().size(), "El tama√±o de la lista de productos no es correcto");
- assertEquals(2, calculadora.suma(1,1), () -> "La suma deber√≠a ser 2");


### Ciclo de vida de una prueba

El ciclo de vida de una prueba en JUnit 5 es el siguiente:

1. **@BeforeAll**: Se ejecuta una vez antes de todos los m√©todos de prueba.
2. **@BeforeEach**: Se ejecuta antes de cada m√©todo de prueba.
3. **@Test**: M√©todo de prueba.
4. **@AfterEach**: Se ejecuta despu√©s de cada m√©todo de prueba.
5. **@AfterAll**: Se ejecuta una vez despu√©s de todos los m√©todos de prueba.

El orden en el que se ejecutan los test es aleatorio, por lo que no se puede garantizar el orden de ejecuci√≥n de los test.

Pero si se necesita garantizar el orden de ejecuci√≥n de los test, se puede utilizar la anotaci√≥n `@Order`.

```java
@Test
@Order(1)
void test1() {
  // Test 1
}

@Test
@Order(2)
void test2() {
  // Test 2
}
```

En este caso, el test1 se ejecutar√° antes que el test2. 

> üí° Si alg√∫n test no tiene la anotaci√≥n `@Order`, se ejecutar√° despu√©s de los test que s√≠ la tengan.

#### Setup y TearDown

En JUnit 5, se pueden utilizar los m√©todos `@BeforeEach` y `@AfterEach` para realizar la configuraci√≥n y limpieza de los recursos necesarios para la ejecuci√≥n de las pruebas.

```java
@BeforeEach
void setUp() {
  // Configuraci√≥n de recursos
}

@AfterEach
void tearDown() {
  // Limpieza de recursos
}
```

#### Deshabilitar pruebas

Los test pueden ser deshabilitados con la anotaci√≥n `@Disabled` o `@Ignore`. (JUnit 5 recomienda indicar un motivo)

```java
public class DisabledTest {

    @Test
    //@Disabled("Until bug #12300 fix")
    void test1() {
        System.out.println("test1");
        assertTrue(true);
    }

    @Test
    @Disabled("Until feature #11900")
    void test2() {
        System.out.println("test2");
        assertTrue(true);
    }

}
```

#### Test condicionales

En JUnit 5, las pruebas unitarias se puede ejecutar conforma a diferentes condiciones.

**@EnabledOnOs**

- Permite habilitar/deshabilitar una prueba en funci√≥n del sistema operativo. @EnabledOnOs({OS.WINDOWS, OS.LINUX}), @DisabledOnOs({OS.MAC})
- Permite habilitar/deshabilitar una prueba en funci√≥n de la versi√≥n de Java. @EnabledOnJre(JRE.JAVA_8), @DisabledOnJre(JRE.JAVA_11)
- o incluso por rangos:
  - @EnabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_11)
  - @DisabledForJreRange(min = JRE.JAVA_8, max = JRE.JAVA_11)

**@EnabledIfSystemProperty**

- Permite habilitar/deshabilitar una prueba en funci√≥n de una propiedad del sistema. @EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
- Se puede usar con: System.getProperty("os.arch")
- Si no existe la propiedad, no se ejecuta.
  - @EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*", disabledReason = "Solo para 64 bits")

**@EnabledIfEnvironmentVariable**

- Permite habilitar/deshabilitar una prueba en funci√≥n de una variable de entorno. @EnabledIfEnvironmentVariable(named = "ENV", matches = ".*dev.*")
  - N√∫mero de n√∫cleos, memoria, etc.
  - Entorno local, DEV, QA, PROD, etc.

**@EnabledIf / @DisableIf**

- Permite habilitar/deshabilitar una prueba en funci√≥n de una expresi√≥n booleana. - El m√©todo encargado de ello estar√° especificado en el test mediante la anotaci√≥n @EnabledIf o @DisabledIf.
- Ser√° est√°tico si se usa a nivel de clase.


Ejemplos de todo esto:

```java
    @EnabledOnJre(JRE.JAVA_8)
    @Test
    void test1() {
        System.out.println("test1 java 8");
    }
    @EnabledOnJre(JRE.JAVA_16)
    @Test
    void test2() {
        System.out.println("test2 java 16");
    }

    @EnabledForJreRange(min = JRE.JAVA_8, max=JRE.JAVA_11)
    @Test
    void test3() {
        System.out.println("test3 range");
    }


    @Test
    @EnabledOnOs(OS.LINUX)
    void test4() {
        System.out.println("test4 linux");
    }
```	

#### Escribir propias condiciones

Dentro de los test-condicionales podemos tener un tipo de test, que se ejecuta en funci√≥n de una condici√≥n que nosotros mismos definimos.

- Permiten habilitar parte de un test en funci√≥n de si se cumple una condici√≥n.
  - assumeTrue(boolean condition)
  - assumeFalse(boolean condition)
- Si la condici√≥n no se cumple, el c√≥digo a partir de ah√≠ se deshabilita, evitando el fallo, es decir, solo queremos probar si se cumple una condici√≥n, sino se cumple, no quremos que falle el test.

```java
    @Test
    void test5() {
        assumeTrue("DEV".equals(System.getenv("ENV")));
        System.out.println("test5");
        // imprime si la variable de entorno ENV es DEV, en caso contrario no se ejecuta y el test queda deshabilitado.
    }
```	

otros ejemplos:

```java
    @Test
    void name() {
        String jdk = System.getenv("JAVA_HOME");
        assumeTrue(jdk.contains("jdk-11"));
        assumeFalse(jdk.contains("jdk-16.0.2"));

        System.out.println("El test continua");
    }

    @Test
    void name2() {
        String jdk = System.getenv("JAVA_HOME");

        assumingThat(jdk.contains("jdk-11"),
                () -> {


                }
        );

    }
```	

### Test anidados

En JUnit 5, se pueden anidar clases de prueba para organizar las pruebas de forma jer√°rquica, por diferentes criterios: funcionalidad, condicionalidad, ...

- Se trata de inner classes en Java.
- Se anotan las clases con @Nested.
- @BeforeAll y @AfterAll no se pueden usar en clases anidadas.
- Se puede incluir una descripci√≥n en dichas clases y los m√©todos que contienen con @DisplayName.
- Los test aparecer√°n en el `reporting` agrupados por clases.
- Si falla un test de una clase anidada, falla la clase anidada y la clase padre.

```java	
@DisplayName("Tests para servicio SmartPhone")
public class ANestedTest {

    @Test
    @DisplayName("Test1")
    void test1() {
        System.out.println("test1");
        assertTrue(true);
    }

    @Nested
    @DisplayName("operaciones recuperar datos")
    class Grupo1 {
        @Test
        @DisplayName("Find all()")
        void test2() {
            System.out.println("test2");
            assertTrue(true);
        }

        @Test
        @DisplayName("Find one()")
        void test3() {
            System.out.println("test3");
            assertTrue(true);
        }

        @Test
        @DisplayName("Find by CPU cores()")
        void test4() {
            System.out.println("test4");
            assertTrue(true);
        }

    }

    @Nested
    @DisplayName("operaciones insercion nuevos datos")
    class Grupo2 {

        @Test
        @DisplayName("Insert one")
        void test5() {
            System.out.println("test5");
            assertTrue(true);
        }

        @Test
        @DisplayName("Insert in batch")
        void test6() {
            System.out.println("test5");
            assertTrue(true);
        }
    }
}

```

### Test repetidos

En JUnit 5, se pueden repetir las pruebas un n√∫mero espec√≠fico de veces.

- Se anotan los m√©todos con @RepeatedTest.
  - √ötil para pruebas de rendimiento.
  - √ötil en m√©todos que presentan comportamiento aleatorio.

- En el reporting se mostrar√° el n√∫mero de veces que se ha repetido el test.
- Se puede combiar el nombre con @DisplayName.
  - @DisplayName: ser√° el t√≠tulo principal.
  - @RepeatedTest: Nombre de cada repetici√≥n.

```java
  public class BRepeatedTest {

    @Test
    void test1() {
        System.out.println("Prueba concepto test1");
    }

    @RepeatedTest(value = 3)
    void test2() {
        System.out.println("Prueba concepto test2");
    }

    @DisplayName("Caso de test 3")
    @RepeatedTest(value = 3, name = RepeatedTest.SHORT_DISPLAY_NAME)
    void test3() {
        System.out.println("Prueba concepto test3");
    }

    @DisplayName("Caso de test 4")
    @RepeatedTest(value = 3, name = RepeatedTest.LONG_DISPLAY_NAME)
    void test4() {
        System.out.println("Prueba concepto test3");
    }

    @DisplayName("Caso de test 4")
    @RepeatedTest(value = 3, name = "{displayName} - {currentRepetition} / {totalRepetitions}")
    void test5() {
        System.out.println("Prueba concepto test3");
    }
}
```

